### PHP Iterator overview
Let's turn our attention to some different patterns in PHP, away from architecture oriented patterns to more day in and day out sorts of problems. First up is iterators. So what is an iterator? The standard definition of an iterator is an object that enables you to traverse a container. It is a solution to a super common problem in PHP and in just about every other programming language, looping over stuff. In essence, an iterator gives us the ability to perform a standard foreach loop over a collection of objects in a programmatic and fast manner. At hearing this, you may be thinking, "And that's impressive, why?" Writing a foreach loop is not particularly challenging. Putting stuff into an array and loop over it, done. What do you need an iterator for? Let's ask a different question. Do you often have multiple foreach loops that you have to execute over a collection of data on different files? Say you have a series of steps that you have to perform for a set of data return from the database, probably at some point you've had this exact type of problem. Any time you think, "yes" to those types of questions, "Do I have multiple foreach loops, "a series of tasks, or a pipeline of work?" think about looking to an iterator to do that type of work. Iterators are great at these types of problems. But why an iterator over just a standard foreach loop? Pretty basic reason, iterators both tend to be faster, as well as less memory intensive to a general foreach loop. They also let us solve and design solutions to problems in much more elegant manners than a typical foreach loop allows us to. 

The real trick with an iterator isn't so much just using them once or twice on a collection of stuff, but instead using a whole group of iterators to work through a large collection of objects. That's the real trick. Iterators are stackable. So we can write one iterator to one solve problem, and then add on others to solve different problems. An iterator lets us write a class focused around one particular problem, and write another different class for a different problem. An iterator, in most cases, is a class that implements these five methods: current, being what the current value in the iterator is; key, being the current key at the current point in the iterator; next, being the next value in the iterator; rewind, meaning to go back to the start of the iterator; and valid, providing a way to check if the current key has a valid value for the iterator. This sequence of operations is the iterator pattern. 

When we loop over the iterator, first rewind is called to reset the iterator. Next, the valid method is called to ensure our value at the first position is valid. We call current or key or whatever our operation is being performed, and then next to advance to the next value in the iterator. And repeat the loop to valid, and then current, or key, next, and etc. So let's review our concept of an iterator. Iterator is a class that gives us the ability to loop over a collection of stuff. And it gives us the ability to build a pipeline of tasks. We can build an iterator that does some filtering, another one that does some organization, and another one that does some calculation.
 
 These iterators can then be stacked to loop over a collection of objects and the data that those objects have to filter, organize, and then calculate, all in a very nice pipeline. Imagine we have a collection of data. We need to first throw out any results that are bad. That's one iterator, a filter iterator, another one that calculates the mean, another that calculates the mode, and another one that calculates the median, and perhaps in the future we know we're going to have to add in more iterators to do more work down the line. That's our pipeline of work that our iterators can do for us.